def bfs(g, v, n):  # g : 그래프 (인접리스트) , v : 시작 지점 , n : 정점의 개수
    # 중복 탐색 방지를 위한 방문 배열
    visited = [False] * (n + 1)  # 인덱스가 몇부터 시작인지를 잘 살펴봐야한다.
    # 정점 번호가 1부터 시작하면 n + 1
    # 정점 번호가 0부터 시작하면 n
    queue = []  # 큐로 사용할 배열 선언
    queue.append(v)  # 탐색을 시작할 초기 위치를 큐에 추가
    visited[v] = True  # 초기 위치는 방문했다고 체크

    # 반복을 계속 하는데
    # 초기에 탐색 시작 위치를 넣어주고 반복을 진행하기 때문에,
    # 탐색 위치가 남아있다면 큐가 비어있을 일이 없다.
    # 큐가 만약 비어있다면 탐색이 끝난 것이다.
    while queue:
        t = queue.pop(0)  # 큐에서 맨 앞의 원소 가져오기
        print(f"{t}", end=" ")
        # 현재 위치인 t에서 갈수 있는 정점들이 있는지 검사
        for i in g[t]:  # 인접 리스트인 g(그래프) 에서 t번 정점과 연결된 정점을 모두 탐색
            if not visited[i]:  # 다음 정점 i 를 방문적이 없다 ==> 탐색 대상이 되고, 탐색 대상은 큐에 추가
                # 큐에 추가 한 후에 탐색했다 라는 표시를 하기 위해서 방문배열에 체크
                queue.append(i)
                visited[i] = True


# 인접 리스트
graph = [[], [2, 3], [1, 4, 5], [1, 7], [2, 6], [2, 6], [4, 5, 7], [3, 6]]

bfs(graph, 1, 7)  # bfs 탐색 시작
